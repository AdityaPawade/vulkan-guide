---
layout: default
title: The render pipeline
parent:  "2. The graphics pipeline, Hello Triangle"
grand_parent: Legacy VkGuide, Vulkan 1.1
nav_order: 10
---

At this point, we managed to setup the main render loop, so it's the time to start rendering things. 

To render things, we have to understand how the Vulkan rendering pipeline works. 

## The render pipeline
The GPU has a lot of functionality used for rendering objects. This is not only the shaders (programs that run on the GPU), but also functionality for the hardware itself.

Think of a GPU as an assembly line. It has a lot of different parts doing different things, and the output is pixels rendered on a Framebuffer. This "assembly line" is what we call the graphics pipeline.

In the graphics pipeline, data and programs come in, and pixels come out. The job of a graphics programmer is to make sure to customize this to get the desired result.

The full-scale Vulkan graphics pipeline is very complex, so we are going to view a simplified version of it.

Data -> Vertex Shader -> Rasterization -> Fragment Shader -> Render Output.

The 2 shader stages will run custom programs that will do anything we want to. The  Rasterization, and Render Output are Fixed stages, and we can only tweak their parameters and configuration.

To begin, we need Data. The Data can be anything we want, and will be our textures, 3d models, material parameters, anything. Everything revolves around data being transformed by the stages until it becomes pixels on the screen.

The vertex shader is a little program that will run once for every vertex we draw. Its job is to output vertex locations and vertex parameters in the way the GPU understands it for the Rasterization stage.

The rasterization stage will grab the vertices generated by the Vertex shader, and it will find what pixels are covered by the triangle. These pixels will be sent to the fragment shader.

The fragment shader takes care of turning those pixels into real colored pixels for the output, running the shader once per pixel that the rasterization stage sends to it.

With the final colored pixels, we put them on the output framebuffer with the Render Output stage. If we have transparent pixels, this stage will blend them, but if it's opaque rendering, it will just overwrite.


## Shaders
To program the GPU, we use shaders. Shaders are a restricted programming model, with their own language and functionality, that is designed for the parallelism of GPUs, and to mesh with the graphics pipeline well.

GPUs, unlike CPUs, have a lot of cores, and those cores are very wide cores, executing a lot of things at once. The amount of data a GPU can crunch at once is staggering, so normal CPU style programming models don't work of it. 

On this tutorial, we are focusing on the minimum we need to render, which is Fragment Shaders and Vertex Shaders



Next: [Setting up triangle shaders]({{ site.baseurl }}{% link docs/chapter-2/triangle_walkthrough.md %})

{% include comments.html term="Chapter 2 Comments" %}

